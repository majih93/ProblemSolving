내 풀이

<script>
  // 1. 두 배열을 오름차순 정렬
  // 2. 두 배열의 인덱스를 두 개의 포인터로 해서 비교하면서, 더 작은 값을 가진 인덱스에 해당하는 포인터를 증가시켜가면서 비교
  // 3. 일치하면 배열에 push
  function solution(arr1, arr2) {
    let answer = [];
    // 정렬
    arr1.sort((a, b) => a - b);
    arr2.sort((a, b) => a - b);

    // 포인터 변수 선언
    let p1 = (p2 = 0);

    // for 문으로 정리

    for (let i = 0; i <= arr1.length; i++) {
      console.log(`${i + 1}번째 for문`);
      if (arr1[p1] > arr2[p2]) {
        p2++;
      } else if (arr1[p1] < arr2[p2]) {
        p1++;
      }

      if (arr1[p1] === arr2[p2]) {
        console.log(arr1[p1]);
        answer.push(arr1[p1]);
        p1++;
        p2++;
      }
      console.log(p1, p2, arr1.length + 1);
      if (p1 === arr1.length || p2 === arr2.length) break;
    }

    return answer;
  }

  let array1 = [11, 3, 9, 2, 23];
  let array2 = [23, 7, 3, 10, 11];
  // console.log(solution(array1, array2));

  // 틀렸던 내용
  // 1. 조건문을 독립적으로 설정하지 않아서 하나의 조건문이 바로 다음 조건문에 영향이 있었음
  // 2. length 여전히 좀 헷갈려하네?
  // 3. 조건문좀 잘짜자 제발!! 생각 좀 해라 제발 좀!!
  // 4. for문을 얼마나 돌려야되는지 정확하게 생각을 못하겠어.
</script>

강의 풀이
<script>
  function solution(arr1, arr2) {
    let answer = [];

    arr1.sort((a, b) => a - b);
    arr2.sort((a, b) => a - b);
    let p1 = (p2 = 0);

    // break 문을 대신하는 while문...
    // for문으로 계속 돌걸 생각해서 경우의 수 따질필요 없이 특정 조건 만족 전에는 계속 돌아가도록 하면 되네....!!
    while (p1 < arr1.length && p2 < arr2.length) {
      if (arr1[p1] === arr2[p2]) {
        answer.push(arr1[p1++]);
        p2++;
      } else if (arr1[p1] < arr2[p2]) p1++;
      else p2++;
    }
    return answer;
  }

  let array3 = [1, 3, 10, 5, 2];
  let array4 = [3, 2, 5, 7, 8];
  console.log(solution(array3, array4));

  // 개선할 내용
  // while문 등 적절한 조건문을 활용하는 능력이 필요함
</script>
